#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# distutils: language = c++
# cython: boundscheck=False
# cython: wraparound=False

# c_animat.pyx


from libcpp.vector cimport vector
from libcpp.string cimport string
from libcpp cimport bool, string

cimport cython

import numpy as np
cimport numpy as cnp


ctypedef unsigned char uchar

# Expose #defined constants to Python.
cdef extern from 'constants.hpp':
    cdef int _CORRECT_CATCH 'CORRECT_CATCH'
    cdef int _WRONG_CATCH 'WRONG_CATCH'
    cdef int _CORRECT_AVOID 'CORRECT_AVOID'
    cdef int _WRONG_AVOID 'WRONG_AVOID'
    cdef int _MIN_BODY_LENGTH 'MIN_BODY_LENGTH'
CORRECT_CATCH = _CORRECT_CATCH
WRONG_CATCH = _WRONG_CATCH
CORRECT_AVOID = _CORRECT_AVOID
WRONG_AVOID = _WRONG_AVOID
MIN_BODY_LENGTH = _MIN_BODY_LENGTH


cdef extern from 'rng.hpp':
    cdef double randDouble()
    cdef int randInt()
    cdef int randCharInt()
    cdef void seedRNG(int s)
    cdef string getState()
    cdef void setState(string state)


def randint():
    """Return a random integer.
    
    Draws from a uniform distribution generated by the C++ mersenne twister
    (mt19937).
    """
    return randInt()


def random():
    """Return a random float between 0 and 1 (inclusive).

    Draws from a uniform distribution generated by the C++ mersenne twister
    (mt19937).
    """
    return randDouble()


def randchar():
    """Return a random integer between 0 and 255 (inclusive).
    
    Draws from a uniform distribution generated by the C++ mersenne twister
    (mt19937).
    """
    return randCharInt()


def seed(s):
    """Seed the C++ random number generator."""
    seedRNG(s)


def get_rng_state():
    """Return the state of the C++ random number generator."""
    return getState()


def set_rng_state(state):
    """Set the state of the C++ random number generator."""
    setState(state)


cdef extern from 'AbstractAgent.hpp':
    cdef cppclass AbstractAgent:
        AbstractAgent(
            vector[uchar] genome, int numSensors, int numHidden, int numMotors,
            bool deterministic
        ) except +

        int mNumSensors
        int mNumHidden
        int mNumMotors
        int mNumNodes
        int mNumStates
        int mBodyLength
        bool mDeterministic

        vector[uchar] genome

        void injectStartCodons(int n, uchar codon_one, uchar codon_two)
        void generatePhenotype();
        void mutateGenome(
            double mutProb, double dupProb, double delProb, int
            minGenomeLength, int maxGenomeLength, int minDupDelLength, 
            int maxDupDelLength)
        vector[vector[bool]] getTransitions()
        void printGates()

cdef extern from 'HiddenMarkovAgent.hpp':
    cdef cppclass HiddenMarkovAgent(AbstractAgent):
        HiddenMarkovAgent(
            vector[uchar] genome, int numSensors, int numHidden, int numMotors,
            bool deterministic
        ) except +

        uchar START_CODON_ONE;
        uchar START_CODON_TWO;

        vector[vector[int]] getEdges()
        void generatePhenotype();

        void injectStartCodons(int n);


cdef extern from 'LinearThresholdAgent.hpp':
    cdef cppclass LinearThresholdAgent(AbstractAgent):
        LinearThresholdAgent(
            vector[uchar] genome, int numSensors, int numHidden, int numMotors,
            bool deterministic
        ) except +

        uchar START_CODON_ONE;
        uchar START_CODON_TWO;

        vector[vector[int]] getEdges()
        void generatePhenotype();

        void injectStartCodons(int n);


cdef extern from 'Game.hpp':
    cdef vector[int] executeGame(
        vector[uchar] animatStates, vector[int] worldStates, 
        vector[int] animatPositions, vector[int] trialResults, 
        AbstractAgent* agent, vector[int] hitMultipliers, vector[int] patterns,
        int worldWidth, int worldHeight, bool scrambleWorld)


cdef extern from 'asvoid.hpp':
    void *asvoid(vector[uchar] *buf)
    void *asvoid(vector[int] *buf)


class StdVectorBase:
    pass


# See https://groups.google.com/d/topic/cython-users/13Bo4zXb930/discussion
cdef class UnsignedCharWrapper:

    cdef vector[uchar] *buf 

    def __cinit__(UnsignedCharWrapper self, n): 
        self.buf = NULL 

    def __init__(UnsignedCharWrapper self, cnp.intp_t n): 
        self.buf = new vector[uchar](n) 

    def __dealloc__(UnsignedCharWrapper self): 
        if self.buf != NULL: 
            del self.buf 

    def asarray(UnsignedCharWrapper self): 
        """Interpret the vector as an np.ndarray without copying the data.""" 
        base = StdVectorBase() 
        intbuf = <cnp.uintp_t> asvoid(self.buf) 
        n = <cnp.intp_t> self.buf.size()
        dtype = np.dtype(np.uint8) 
        base.__array_interface__ = dict( 
            data=(intbuf, False), 
            descr=dtype.descr, 
            shape=(n,),
            strides=(dtype.itemsize,), 
            typestr=dtype.str, 
            version=3,
        ) 
        base.vector_wrapper = self 
        return np.asarray(base) 


cdef class Int32Wrapper:

    cdef vector[int] *buf 

    def __cinit__(int self, n): 
        self.buf = NULL 

    def __init__(int self, cnp.intp_t n): 
        self.buf = new vector[int](n) 

    def __dealloc__(int self): 
        if self.buf != NULL: 
            del self.buf 

    def asarray(int self): 
        """Interpret the vector as an np.ndarray without copying the data.""" 
        base = StdVectorBase() 
        intbuf = <cnp.uintp_t> asvoid(self.buf) 
        n = <cnp.intp_t> self.buf.size()
        dtype = np.dtype(np.int32) 
        base.__array_interface__ = dict( 
            data=(intbuf, False), 
            descr=dtype.descr, 
            shape=(n,),
            strides=(dtype.itemsize,), 
            typestr=dtype.str, 
            version=3,
        ) 
        base.vector_wrapper = self 
        return np.asarray(base) 


cdef class pyAbstractAgent:
    # Hold the C++ instance that we're wrapping.
    cdef AbstractAgent *thisptr
    cdef bool _dirty_phenotype

    def __reduce__(self):
        # When pickling or copying, simply regenerate an instance.
        # NOTE: This means that changes in the implementation of
        # pyAbstractAgent that occur between pickling and unpickling can cause
        # a SILENT change in behavior!
        return (pyAbstractAgent, (self.genome, self.num_sensors,
                                  self.num_hidden, self.num_motors,
                                  self.deterministic))

    property genome:
        def __get__(self):
            return self.thisptr.genome

    property num_sensors:
        def __get__(self):
            return self.thisptr.mNumSensors

    property num_hidden:
        def __get__(self):
            return self.thisptr.mNumHidden

    property num_motors:
        def __get__(self):
            return self.thisptr.mNumMotors

    property num_nodes:
        def __get__(self):
            return self.thisptr.mNumNodes

    property num_states:
        def __get__(self):
            return self.thisptr.mNumStates

    property deterministic:
        def __get__(self):
            return self.thisptr.mDeterministic

    property body_length:
        def __get__(self):
            return self.thisptr.mBodyLength

    property tpm:
        def __get__(self):
            # Update the phenotype if necessary before getting the TPM.
            self._update_phenotype()
            return self.thisptr.getTransitions()

    def _update_phenotype(self):
        if self._dirty_phenotype:
            self.thisptr.generatePhenotype()
            self._dirty_phenotype = False

    def print_gates(self):
        self.thisptr.printGates()

    def mutate(self, mutProb, dupProb, delProb, minGenomeLength,
               maxGenomeLength, minDupDelLength, maxDupDelLength):
        self.thisptr.mutateGenome(mutProb, dupProb, delProb, minGenomeLength,
                                  maxGenomeLength, minDupDelLength,
                                  maxDupDelLength)
        # The phenotype now needs to be updated.
        self._dirty_phenotype = True

    def play_game(self, hit_multipliers, patterns, worldWidth, worldHeight,
                  scramble_world=False):
        # Ensure the phenotype reflects the genome before playing the game.
        self._update_phenotype()
        # Calculate the size of the state transition vector, which has an entry
        # for every node state of every timestep of every trial, and initialize.
        num_trials = len(patterns) * 2 * worldWidth
        num_timesteps = num_trials * worldHeight
        cdef UnsignedCharWrapper animat_states = \
            UnsignedCharWrapper(num_timesteps * self.num_nodes)
        cdef Int32Wrapper world_states = Int32Wrapper(num_timesteps)
        cdef Int32Wrapper animat_positions = Int32Wrapper(num_timesteps)
        cdef Int32Wrapper trial_results = Int32Wrapper(num_trials)
        # Play the game, updating the animats hit and miss counts and filling
        # the given transition vector with the states the animat went through.
        correct, incorrect = executeGame(
            animat_states.buf[0], world_states.buf[0], animat_positions.buf[0],
            trial_results.buf[0], self.thisptr, hit_multipliers, patterns,
            worldWidth, worldHeight, scramble_world)
        # Return the state transitions and world states as NumPy arrays.
        return (animat_states.asarray(), world_states.asarray(),
                animat_positions.asarray(), trial_results.asarray(), correct,
                incorrect)


cdef class pyHiddenMarkovAgent(pyAbstractAgent):
    cdef HiddenMarkovAgent *derivedptr

    def __cinit__(self, genome, numSensors, numHidden, numMotors,
                  deterministic):
        self.derivedptr = new HiddenMarkovAgent(genome, numSensors, numHidden,
                                       numMotors, deterministic)
        self.thisptr = self.derivedptr
        self._dirty_phenotype = True

    def __dealloc__(self):
        del self.derivedptr

    property START_CODON_ONE:
        def __get__(self):
            return self.derivedptr.START_CODON_ONE

    property START_CODON_TWO:
        def __get__(self):
            return self.derivedptr.START_CODON_TWO

    property edges:
        def __get__(self):
            # Update the phenotype if necessary before getting the edge list.
            self._update_phenotype()
            return self.derivedptr.getEdges()

    def injectStartCodons(self, n):
        self.derivedptr.injectStartCodons(n)


cdef class pyLinearThresholdAgent(pyAbstractAgent):
    cdef LinearThresholdAgent *derivedptr

    def __cinit__(self, genome, numSensors, numHidden, numMotors,
                  deterministic):
        self.derivedptr = new LinearThresholdAgent(genome, numSensors,
                                                   numHidden, numMotors,
                                                   deterministic)
        self.thisptr = self.derivedptr
        self._dirty_phenotype = True

    property START_CODON_ONE:
        def __get__(self):
            return self.derivedptr.START_CODON_ONE

    property START_CODON_TWO:
        def __get__(self):
            return self.derivedptr.START_CODON_TWO

    def __dealloc__(self):
        del self.derivedptr

    property edges:
        def __get__(self):
            # Update the phenotype if necessary before getting the edge list.
            self._update_phenotype()
            return self.derivedptr.getEdges()

    def injectStartCodons(self, n):
        self.derivedptr.injectStartCodons(n)

